
#include <opencv2/imgcodecs.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <cstdio>
#include <iostream>
#include <memory>
#include <stdexcept>
#include <string>

using namespace cv;

const int           MIN_AREA = 10000;
const int           KERNEL_SIZE = 7;
const int           dilation_size = 5;
const int           resize_to_height = 480;
const double        SIGMA = 4.5;
const std::string   PROGRAM_PATH = "/usr/local/bin/"; // for some simplify path finding, but system relative
const std::string   Youtube_URL = "https://www.youtube.com/watch?v=";
const std::string   downloader = "youtube-dl";

std::string cmdExec(const char* command)
{
    char buf[512];
    std::string result = "";
    std::shared_ptr<FILE> pipe(popen(command, "r"), pclose);
    if (!pipe) throw std::runtime_error("popen() failed!");
    while (!feof(pipe.get())) {
        if (fgets(buf, 512, pipe.get()) != NULL)
            result += buf;
    }
    return result;
}

Rect resizeRect(Rect r,float scale)
{
    return Rect(r.x*scale,r.y*scale,r.width*scale,r.height*scale);
}

int main(int, char**)
{
    std::string cmd, stream_id, stream_URL, FormatCode;
    std::vector<int> compression_params;
    compression_params.push_back(CV_IMWRITE_JPEG_QUALITY);
    compression_params.push_back(95);
    
    std::cout << Youtube_URL;
    getline(std::cin, stream_id); // getting video id
    
    cmd = PROGRAM_PATH + downloader + " -F " + Youtube_URL + stream_id;
    std::cout << cmdExec(cmd.c_str()) << std::endl; // query the list of available formats
    
    std::cout << "Enter format code: ";
    getline(std::cin, FormatCode); // getting desired format code
    
    cmd = PROGRAM_PATH + downloader + " -f " + FormatCode + " -g " + Youtube_URL + stream_id;
    stream_URL = cmdExec(cmd.c_str()); // getting complete stream URL
    
    //VideoCapture cap(0); // open the default camera
    
    VideoCapture cap(stream_URL.substr(0, stream_URL.size()-1)); // open the stream URL
    if(!cap.isOpened()) // check if we succeeded
        return -1;
    
    std::cout << "Processing..." << std::endl;
    
    // create Background Subtractor objects
    
    Mat fgMaskMOG2; // fg mask fg mask generated by MOG2 method
    Ptr<BackgroundSubtractor> pMOG2; // MOG2 Background subtractor
    pMOG2 = createBackgroundSubtractorMOG2(); // MOG2 approach
    
    Mat firstFrame;
    int fnum = 0;
    bool motion = false;
    
    for(int n = 0; n < 100; n++) // test on only first 100 frames
    {
        Mat frame, gray_frame;
        cap >> frame; // get a new frame from camera
        
        cvtColor(frame, gray_frame, COLOR_BGR2GRAY); //switch to grayscale
        
        float scale =(float) resize_to_height/gray_frame.rows;
        int resized_width = gray_frame.cols*scale;
        resize(gray_frame, gray_frame, Size(resized_width,resize_to_height), 0, 0, CV_INTER_CUBIC); // resize
        
        GaussianBlur(gray_frame, gray_frame, Size(KERNEL_SIZE,KERNEL_SIZE), SIGMA, SIGMA);
        pMOG2->apply(gray_frame, fgMaskMOG2);
        
        Mat dilated;
        Mat element = getStructuringElement( MORPH_ELLIPSE,
                                            Size( 2*dilation_size + 1, 2*dilation_size+1 ),
                                            Point( dilation_size, dilation_size ) );
        dilate(fgMaskMOG2,dilated,element); // dilate the thresholded image to fill in holes, then find contours on thresholded image
        
        std::vector<std::vector<Point> > contours;
        std::vector<Vec4i> hierarchy;
        findContours( dilated, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point(0, 0) ); //find contours
        
        motion = false;
        for( int i = 0; i< contours.size(); i++ ) // loop over the contours
        {
            double area = contourArea(contours[i]);
            if(area < MIN_AREA)
                continue;
            
            motion = true;
            CvRect r = boundingRect(contours[i]);
            r = resizeRect(r,1.0/scale);
            Scalar color = Scalar(255, 0,0 );
            rectangle( frame, r,color);
        }
        
        if(motion)
            
        {
            std::stringstream fname;
            fname << "img_"<<fnum<<".jpg";
            imwrite(fname.str(), frame, compression_params); // save image
        }
        fnum++;
    }
    
    // the camera will be deinitialized automatically in VideoCapture destructor
    return 0;
}
