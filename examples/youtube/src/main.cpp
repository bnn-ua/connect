#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <sstream>

using namespace cv;

const int MIN_AREA = 10000;
const int KERNEL_SIZE = 7;
const int SIGMA = 4.5;
const int dilation_size = 5;
const int resize_to_height = 480;

Rect resizeRect(Rect r,float scale)
{
	return Rect(r.x*scale,r.y*scale,r.width*scale,r.height*scale);
}

int main(int, char**)
{
	std::vector<int> compression_params;
	compression_params.push_back(CV_IMWRITE_JPEG_QUALITY);
	compression_params.push_back(95);


    VideoCapture cap(0); // open the default camera
    if(!cap.isOpened())  // check if we succeeded
        return -1;

    //create Background Subtractor objects
    Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
    Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

    Mat firstFrame;
    int fnum=0;
    bool motion = false;
    for(;;)
    {
        Mat frame,gray_frame;
        cap >> frame; // get a new frame from camera
        //switch to grayscale
        cvtColor(frame, gray_frame, COLOR_BGR2GRAY);
        //resize
        float scale =(float) resize_to_height/gray_frame.rows;
        int resized_width = gray_frame.cols*scale;
        resize(gray_frame, gray_frame, Size(resized_width,resize_to_height), 0, 0, CV_INTER_CUBIC);
        GaussianBlur(gray_frame, gray_frame, Size(KERNEL_SIZE,KERNEL_SIZE), SIGMA, SIGMA);
        pMOG2->apply(gray_frame, fgMaskMOG2);
       /* {//save image
        	std::stringstream fname;
        	fname << "fg_"<<fnum<<".jpg";
        	imwrite(fname.str(), fgMaskMOG2, compression_params);
        }*/

		//dilate the thresholded image to fill in holes, then find contours
	    //on thresholded image
        Mat dilated;
		Mat element = getStructuringElement( MORPH_ELLIPSE,
		                       Size( 2*dilation_size + 1, 2*dilation_size+1 ),
		                       Point( dilation_size, dilation_size ) );
		dilate(fgMaskMOG2,dilated,element);
		//find contours
		std::vector<std::vector<Point> > contours;
		std::vector<Vec4i> hierarchy;
		findContours( dilated, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point(0, 0) );


	    //loop over the contours
		motion = false;
		for( int i = 0; i< contours.size(); i++ )
		{
			double area = contourArea(contours[i]);
			if(area < MIN_AREA)
				continue;

			motion = true;
			CvRect r = boundingRect(contours[i]);
			r = resizeRect(r,1.0/scale);
			Scalar color = Scalar(255, 0,0 );
		    rectangle( frame, r,color);
		}

		if(motion)
		{//save image
			std::stringstream fname;
			fname << "img_"<<fnum<<".jpg";
			imwrite(fname.str(), frame, compression_params);
		}

		fnum++;
    }
    // the camera will be deinitialized automatically in VideoCapture destructor
    return 0;
}
